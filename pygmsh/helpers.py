import gmsh
import meshio
import numpy


def rotation_matrix(u, theta):
    """Return matrix that implements the rotation around the vector :math:`u`
    by the angle :math:`\\theta`, cf.
    https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle.

    :param u: rotation vector
    :param theta: rotation angle
    """
    assert numpy.isclose(numpy.inner(u, u), 1.0), "the rotation axis must be unitary"

    # Cross-product matrix.
    cpm = numpy.array([[0.0, -u[2], u[1]], [u[2], 0.0, -u[0]], [-u[1], u[0], 0.0]])
    c = numpy.cos(theta)
    s = numpy.sin(theta)
    R = numpy.eye(3) * c + s * cpm + (1.0 - c) * numpy.outer(u, u)
    return R


def orient_lines(lines):
    """Given a sequence of unordered and unoriented lines defining a closed polygon,
    returns a reordered list of reoriented lines of that polygon.

    :param lines: a sequence of lines defining a closed polygon
    """
    # Categorise graph edges by their vertex pair ids
    point_pair_ids = numpy.array(
        [[line.points[0]._ID, line.points[1]._ID] for line in lines]
    )

    # Indices of reordering
    order = numpy.arange(len(point_pair_ids), dtype=int)
    # Compute orientations where oriented[j] == False requires edge j to be reversed
    oriented = numpy.array([True] * len(point_pair_ids), dtype=numpy.bool)

    for j in range(1, len(point_pair_ids)):
        out = point_pair_ids[j - 1, 1]  # edge out from vertex
        inn = point_pair_ids[j:, 0]  # candidates for edge into vertices
        wh = numpy.where(inn == out)[0] + j
        if len(wh) == 0:
            # look for candidates in those which are not correctly oriented
            inn = point_pair_ids[j:, 1]
            wh = numpy.where(inn == out)[0] + j
            # reorient remaining edges
            point_pair_ids[j:] = numpy.flip(point_pair_ids[j:], axis=1)
            oriented[j:] ^= True

        # reorder
        point_pair_ids[[j, wh[0]]] = point_pair_ids[[wh[0], j]]
        order[[j, wh[0]]] = order[[wh[0], j]]

    # Reconstruct an ordered and oriented line loop
    lines = [lines[o] for o in order]
    lines = [lines[j] if oriented[j] else -lines[j] for j in range(len(oriented))]

    return lines


def generate_mesh(  # noqa: C901
    geo_object,
    verbose=True,
    dim=3,
    order=None,
    prune_vertices=True,
    prune_z_0=False,
    remove_lower_dim_cells=False,
):
    """Return a meshio.Mesh, storing the mesh points, cells, and data, generated by Gmsh
    from the `geo_object`, written to a temporary file, and reread by `meshio`.

    Gmsh's native "msh" format is ill-suited to fast I/O.  This can greatly reduce the
    performance of pygmsh.  As alternatives, try `mesh_file_type=`:

    - "vtk"`, though Gmsh doesn't write the physical tags to VTK
      <https://gitlab.onelab.info/gmsh/gmsh/issues/389> or

    - `"mesh"`, though this only supports a few basic elements - "line", "triangle",
      "quad", "tetra", "hexahedron" - and doesn't preserve the `$PhysicalNames`, just
      the `int` tags.
    """
    geo_object.synchronize()

    for item in geo_object._AFTER_SYNC_QUEUE:
        item.exec()

    for item, host in geo_object._EMBED_QUEUE:
        gmsh.model.mesh.embed(item.dimension, [item._ID], host.dimension, host._ID)

    # set compound entities after sync
    for c in geo_object._COMPOUND_ENTITIES:
        gmsh.model.mesh.setCompound(*c)

    for s in geo_object._RECOMBINE_ENTITIES:
        gmsh.model.mesh.setRecombine(*s)

    for t in geo_object._TRANSFINITE_CURVE_QUEUE:
        gmsh.model.geo.mesh.setTransfiniteCurve(*t)

    for t in geo_object._TRANSFINITE_SURFACE_QUEUE:
        gmsh.model.geo.mesh.setTransfiniteSurface(*t)

    for item, size in geo_object._SIZE_QUEUE:
        gmsh.model.mesh.setSize(
            gmsh.model.getBoundary(item.dim_tags, False, False, True), size
        )

    if order is not None:
        gmsh.model.mesh.setOrder(order)

    gmsh.model.mesh.generate(dim)

    # extract point coords
    idx, points, _ = gmsh.model.mesh.getNodes()
    points = points.reshape(-1, 3)
    idx -= 1
    srt = numpy.argsort(idx)
    assert numpy.all(idx[srt] == numpy.arange(len(idx)))
    points = points[srt]
    if prune_z_0 and numpy.all(numpy.abs(points[:, 2]) < 1.0e-13):
        points = points[:, :2]

    # extract cells
    elem_types, elem_tags, node_tags = gmsh.model.mesh.getElements()
    cells = []
    for elem_type, node_tags in zip(elem_types, node_tags):
        # `elementName', `dim', `order', `numNodes', `localNodeCoord', `numPrimaryNodes'
        num_nodes_per_cell = gmsh.model.mesh.getElementProperties(elem_type)[3]
        meshio.gmsh.gmsh_to_meshio_type
        cells.append(
            meshio.CellBlock(
                meshio.gmsh.gmsh_to_meshio_type[elem_type],
                node_tags.reshape(-1, num_nodes_per_cell) - 1,
            )
        )

    # print("a", gmsh.model.getEntities())
    # grps = gmsh.model.getPhysicalGroups()
    # print("a", grps)
    # for dim, tag in grps:
    #     print("a", gmsh.model.getPhysicalName(dim, tag))
    #     ent = gmsh.model.getEntitiesForPhysicalGroup(dim, tag)
    #     print("a", ent)
    #     assert len(ent) == 1
    #     print("a", gmsh.model.mesh.getElements(dim, ent[0]))

    # make meshio mesh
    mesh = meshio.Mesh(points, cells)

    if remove_lower_dim_cells:
        # Only keep the cells of highest topological dimension; discard faces and such.
        cells_2d = {"triangle", "quad"}
        cells_3d = {
            "tetra",
            "hexahedron",
            "wedge",
            "pyramid",
            "penta_prism",
            "hexa_prism",
        }
        if any(c.type in cells_3d for c in mesh.cells):
            keep_types = cells_3d
        elif any(c.type in cells_2d for c in mesh.cells):
            keep_types = cells_2d
        else:
            keep_types = set(cell_type for cell_type, _ in mesh.cells)

        for name, val in mesh.cell_data.items():
            mesh.cell_data[name] = [
                d for d, c in zip(val, mesh.cells) if c[0] in keep_types
            ]
        mesh.cells = [c for c in mesh.cells if c[0] in keep_types]

    if prune_vertices:
        # Make sure to include only those vertices which belong to a cell.
        ncells = numpy.concatenate([numpy.concatenate(c) for _, c in mesh.cells])
        uvertices, uidx = numpy.unique(ncells, return_inverse=True)

        k = 0
        cells = []
        for key, cellblock in mesh.cells:
            n = numpy.prod(cellblock.shape)
            cells.append(
                meshio.CellBlock(key, uidx[k : k + n].reshape(cellblock.shape))
            )
            k += n
        mesh.cells = cells

        mesh.points = mesh.points[uvertices]
        for key in mesh.point_data:
            mesh.point_data[key] = mesh.point_data[key][uvertices]

    return mesh
